# EcoOs_Lab2

## 1. Постановка задачи
Требуется расширить функциональность существующего компонента, добавив в него компоненты калькулятора, которые выполняют базовые арифметические операции: сложение, вычитание, умножение и деление. Реализация должна быть выполнена с использованием принципов включения (composition) и агрегирования (aggregation).

## 2. Реализация
Для построения системы были применены два ключевых подхода:

Включение (Композиция): Объект-компонент является неотъемлемой частью основного объекта. Их жизненные циклы жестко связаны: при уничтожении основного объекта автоматически уничтожаются и все его включенные компоненты.

Агрегирование: Объекты связаны более слабо. Жизненные циклы агрегированного объекта и объекта-контейнера независимы.

<img width="3680" height="4736" alt="image" src="https://github.com/user-attachments/assets/712e5326-4359-4c99-a1c7-da16af30facc" />

<img width="3680" height="4196" alt="image" src="https://github.com/user-attachments/assets/f6dd742a-ff54-47d6-b462-25235c5cf611" />

<img width="3680" height="3208" alt="image" src="https://github.com/user-attachments/assets/e8cc6bbc-2b25-449e-9bf0-9a7865688c68" />




## 3. Пример работы
В ходе демонстрации была проверена корректность работы всех арифметических операций. Основное внимание было уделено механизму QueryInterface, который обеспечивает гибкость системы: из любого интерфейса можно получить доступ к любому другому интерфейсу компонента. В завершении пользователю предоставляется возможность запустить модульные тесты для проверки функциональности.
<img width="1089" height="532" alt="image" src="https://github.com/user-attachments/assets/424f4788-caad-4c59-b67d-0acddda632c9" />



##  4. Выводы
Разработанный компонент калькулятора успешно реализует заданные требования:

Интегрированы компоненты для операций сложения, вычитания, умножения и деления.

Корректно применены приемы включения и агрегирования для управления жизненным циклом объектов.

Реализован механизм QueryInterface, обеспечивающий возможность получения любого интерфейса из любого другого, что подтверждено на практике.

Такой архитектурный подход демонстрирует высокую гибкость и расширяемость системы. Добавление новых операций в будущем не потребует изменения существующего кода, что соответствует принципу открытости/закрытости (Open/Closed Principle) в объектно-ориентированном программировании.
